<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.11) on Fri Sep 16 17:15:50 PDT 2022 -->
<title>GetHLSStreamingSessionURLRequest (AWS SDK for Android - 2.53.0)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-09-16">
<link rel="stylesheet" type="text/css" href="../../../../../JavaDoc.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GetHLSStreamingSessionURLRequest (AWS SDK for Android - 2.53.0)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.amazonaws.services.kinesisvideoarchivedmedia.model</a></div>
<h2 title="Class GetHLSStreamingSessionURLRequest" class="title">Class GetHLSStreamingSessionURLRequest</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../../AmazonWebServiceRequest.html" title="class in com.amazonaws">com.amazonaws.AmazonWebServiceRequest</a></li>
<li>
<ul class="inheritance">
<li>com.amazonaws.services.kinesisvideoarchivedmedia.model.GetHLSStreamingSessionURLRequest</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.io.Serializable</code>, <code>java.lang.Cloneable</code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">GetHLSStreamingSessionURLRequest</span>
extends <a href="../../../AmazonWebServiceRequest.html" title="class in com.amazonaws">AmazonWebServiceRequest</a>
implements java.io.Serializable</pre>
<div class="block"><p>
 Retrieves an HTTP Live Streaming (HLS) URL for the stream. You can then open
 the URL in a browser or media player to view the stream contents.
 </p>
 <p>
 Both the <code>StreamName</code> and the <code>StreamARN</code> parameters
 are optional, but you must specify either the <code>StreamName</code> or the
 <code>StreamARN</code> when invoking this API operation.
 </p>
 <p>
 An Amazon Kinesis video stream has the following requirements for providing
 data through HLS:
 </p>
 <ul>
 <li>
 <p>
 The media must contain h.264 or h.265 encoded video and, optionally, AAC
 encoded audio. Specifically, the codec ID of track 1 should be
 <code>V_MPEG/ISO/AVC</code> (for h.264) or <code>V_MPEG/ISO/HEVC</code> (for
 h.265). Optionally, the codec ID of track 2 should be <code>A_AAC</code>.
 </p>
 </li>
 <li>
 <p>
 Data retention must be greater than 0.
 </p>
 </li>
 <li>
 <p>
 The video track of each fragment must contain codec private data in the
 Advanced Video Coding (AVC) for H.264 format or HEVC for H.265 format (<a href="https://www.iso.org/standard/55980.html">MPEG-4 specification ISO/IEC
 14496-15</a>). For information about adapting stream data to a given format,
 see <a href="http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/producer-reference-nal.html">NAL Adaptation Flags</a>.
 </p>
 </li>
 <li>
 <p>
 The audio track (if present) of each fragment must contain codec private data
 in the AAC format (<a href="https://www.iso.org/standard/43345.html">AAC
 specification ISO/IEC 13818-7</a>).
 </p>
 </li>
 </ul>
 <p>
 Kinesis Video Streams HLS sessions contain fragments in the fragmented MPEG-4
 form (also called fMP4 or CMAF) or the MPEG-2 form (also called TS chunks,
 which the HLS specification also supports). For more information about HLS
 fragment types, see the <a href="https://tools.ietf.org/html/draft-pantos-http-live-streaming-23">HLS
 specification</a>.
 </p>
 <p>
 The following procedure shows how to use HLS with Kinesis Video Streams:
 </p>
 <ol>
 <li>
 <p>
 Get an endpoint using <a href="http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_GetDataEndpoint.html">GetDataEndpoint</a>, specifying <code>GET_HLS_STREAMING_SESSION_URL</code>
 for the <code>APIName</code> parameter.
 </p>
 </li>
 <li>
 <p>
 Retrieve the HLS URL using <code>GetHLSStreamingSessionURL</code>. Kinesis
 Video Streams creates an HLS streaming session to be used for accessing
 content in a stream using the HLS protocol.
 <code>GetHLSStreamingSessionURL</code> returns an authenticated URL (that
 includes an encrypted session token) for the session's HLS <i>master
 playlist</i> (the root resource needed for streaming with HLS).
 </p>
 <note>
 <p>
 Don't share or store this token where an unauthorized entity could access it.
 The token provides access to the content of the stream. Safeguard the token
 with the same measures that you would use with your AWS credentials.
 </p>
 </note>
 <p>
 The media that is made available through the playlist consists only of the
 requested stream, time range, and format. No other media data (such as frames
 outside the requested window or alternate bitrates) is made available.
 </p>
 </li>
 <li>
 <p>
 Provide the URL (containing the encrypted session token) for the HLS master
 playlist to a media player that supports the HLS protocol. Kinesis Video
 Streams makes the HLS media playlist, initialization fragment, and media
 fragments available through the master playlist URL. The initialization
 fragment contains the codec private data for the stream, and other data
 needed to set up the video or audio decoder and renderer. The media fragments
 contain H.264-encoded video frames or AAC-encoded audio samples.
 </p>
 </li>
 <li>
 <p>
 The media player receives the authenticated URL and requests stream metadata
 and media data normally. When the media player requests data, it calls the
 following actions:
 </p>
 <ul>
 <li>
 <p>
 <b>GetHLSMasterPlaylist:</b> Retrieves an HLS master playlist, which contains
 a URL for the <code>GetHLSMediaPlaylist</code> action for each track, and
 additional metadata for the media player, including estimated bitrate and
 resolution.
 </p>
 </li>
 <li>
 <p>
 <b>GetHLSMediaPlaylist:</b> Retrieves an HLS media playlist, which contains a
 URL to access the MP4 initialization fragment with the
 <code>GetMP4InitFragment</code> action, and URLs to access the MP4 media
 fragments with the <code>GetMP4MediaFragment</code> actions. The HLS media
 playlist also contains metadata about the stream that the player needs to
 play it, such as whether the <code>PlaybackMode</code> is <code>LIVE</code>
 or <code>ON_DEMAND</code>. The HLS media playlist is typically static for
 sessions with a <code>PlaybackType</code> of <code>ON_DEMAND</code>. The HLS
 media playlist is continually updated with new fragments for sessions with a
 <code>PlaybackType</code> of <code>LIVE</code>. There is a distinct HLS media
 playlist for the video track and the audio track (if applicable) that
 contains MP4 media URLs for the specific track.
 </p>
 </li>
 <li>
 <p>
 <b>GetMP4InitFragment:</b> Retrieves the MP4 initialization fragment. The
 media player typically loads the initialization fragment before loading any
 media fragments. This fragment contains the "<code>fytp</code>" and "
 <code>moov</code>" MP4 atoms, and the child atoms that are needed to
 initialize the media player decoder.
 </p>
 <p>
 The initialization fragment does not correspond to a fragment in a Kinesis
 video stream. It contains only the codec private data for the stream and
 respective track, which the media player needs to decode the media frames.
 </p>
 </li>
 <li>
 <p>
 <b>GetMP4MediaFragment:</b> Retrieves MP4 media fragments. These fragments
 contain the "<code>moof</code>" and "<code>mdat</code>" MP4 atoms and their
 child atoms, containing the encoded fragment's media frames and their
 timestamps.
 </p>
 <note>
 <p>
 After the first media fragment is made available in a streaming session, any
 fragments that don't contain the same codec private data cause an error to be
 returned when those different media fragments are loaded. Therefore, the
 codec private data should not change between fragments in a session. This
 also means that the session fails if the fragments in a stream change from
 having only video to having both audio and video.
 </p>
 </note>
 <p>
 Data retrieved with this action is billable. See <a href="https://aws.amazon.com/kinesis/video-streams/pricing/">Pricing</a> for
 details.
 </p>
 </li>
 <li>
 <p>
 <b>GetTSFragment:</b> Retrieves MPEG TS fragments containing both
 initialization and media data for all tracks in the stream.
 </p>
 <note>
 <p>
 If the <code>ContainerFormat</code> is <code>MPEG_TS</code>, this API is used
 instead of <code>GetMP4InitFragment</code> and
 <code>GetMP4MediaFragment</code> to retrieve stream media.
 </p>
 </note>
 <p>
 Data retrieved with this action is billable. For more information, see <a href="https://aws.amazon.com/kinesis/video-streams/pricing/">Kinesis Video
 Streams pricing</a>.
 </p>
 </li>
 </ul>
 </li>
 </ol>
 <p>
 A streaming session URL must not be shared between players. The service might
 throttle a session if multiple media players are sharing it. For connection
 limits, see <a href="http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/limits.html">Kinesis Video Streams Limits</a>.
 </p>
 <p>
 You can monitor the amount of data that the media player consumes by
 monitoring the <code>GetMP4MediaFragment.OutgoingBytes</code> Amazon
 CloudWatch metric. For information about using CloudWatch to monitor Kinesis
 Video Streams, see <a href="http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/monitoring.html">Monitoring Kinesis Video Streams</a>. For pricing information, see <a href="https://aws.amazon.com/kinesis/video-streams/pricing/">Amazon Kinesis
 Video Streams Pricing</a> and <a href="https://aws.amazon.com/pricing/">AWS
 Pricing</a>. Charges for both HLS sessions and outgoing AWS data apply.
 </p>
 <p>
 For more information about HLS, see <a href="https://developer.apple.com/streaming/">HTTP Live Streaming</a> on the
 <a href="https://developer.apple.com">Apple Developer site</a>.
 </p>
 <important>
 <p>
 If an error is thrown after invoking a Kinesis Video Streams archived media
 API, in addition to the HTTP status code and the response body, it includes
 the following pieces of information:
 </p>
 <ul>
 <li>
 <p>
 <code>x-amz-ErrorType</code> HTTP header – contains a more specific error
 type in addition to what the HTTP status code provides.
 </p>
 </li>
 <li>
 <p>
 <code>x-amz-RequestId</code> HTTP header – if you want to report an issue to
 AWS, the support team can better diagnose the problem if given the Request
 Id.
 </p>
 </li>
 </ul>
 <p>
 Both the HTTP status code and the ErrorType header can be utilized to make
 programmatic decisions about whether errors are retry-able and under what
 conditions, as well as provide information on what actions the client
 programmer might need to take in order to successfully try again.
 </p>
 <p>
 For more information, see the <b>Errors</b> section at the bottom of this
 topic, as well as <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/CommonErrors.html">Common Errors</a>.
 </p>
 </important></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../serialized-form.html#com.amazonaws.services.kinesisvideoarchivedmedia.model.GetHLSStreamingSessionURLRequest">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">GetHLSStreamingSessionURLRequest</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equals(java.lang.Object)">equals</a></span>&#8203;(java.lang.Object&nbsp;obj)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContainerFormat()">getContainerFormat</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Specifies which format should be used for packaging the media.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDiscontinuityMode()">getDiscontinuityMode</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDisplayFragmentTimestamp()">getDisplayFragmentTimestamp</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>java.lang.Integer</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getExpires()">getExpires</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The time in seconds until the requested session expires.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="HLSFragmentSelector.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSFragmentSelector</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getHLSFragmentSelector()">getHLSFragmentSelector</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The time range of the requested fragment and the source of the
 timestamps.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>java.lang.Long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxMediaPlaylistFragmentResults()">getMaxMediaPlaylistFragmentResults</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The maximum number of fragments that are returned in the HLS media
 playlists.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPlaybackMode()">getPlaybackMode</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether to retrieve live, live replay, or archived, on-demand data.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getStreamARN()">getStreamARN</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The Amazon Resource Name (ARN) of the stream for which to retrieve the
 HLS master playlist URL.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getStreamName()">getStreamName</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The name of the stream for which to retrieve the HLS master playlist URL.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashCode()">hashCode</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setContainerFormat(com.amazonaws.services.kinesisvideoarchivedmedia.model.ContainerFormat)">setContainerFormat</a></span>&#8203;(<a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">ContainerFormat</a>&nbsp;containerFormat)</code></th>
<td class="colLast">
<div class="block">
 Specifies which format should be used for packaging the media.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setContainerFormat(java.lang.String)">setContainerFormat</a></span>&#8203;(java.lang.String&nbsp;containerFormat)</code></th>
<td class="colLast">
<div class="block">
 Specifies which format should be used for packaging the media.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDiscontinuityMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDiscontinuityMode)">setDiscontinuityMode</a></span>&#8203;(<a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDiscontinuityMode</a>&nbsp;discontinuityMode)</code></th>
<td class="colLast">
<div class="block">
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDiscontinuityMode(java.lang.String)">setDiscontinuityMode</a></span>&#8203;(java.lang.String&nbsp;discontinuityMode)</code></th>
<td class="colLast">
<div class="block">
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDisplayFragmentTimestamp(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDisplayFragmentTimestamp)">setDisplayFragmentTimestamp</a></span>&#8203;(<a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDisplayFragmentTimestamp</a>&nbsp;displayFragmentTimestamp)</code></th>
<td class="colLast">
<div class="block">
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDisplayFragmentTimestamp(java.lang.String)">setDisplayFragmentTimestamp</a></span>&#8203;(java.lang.String&nbsp;displayFragmentTimestamp)</code></th>
<td class="colLast">
<div class="block">
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setExpires(java.lang.Integer)">setExpires</a></span>&#8203;(java.lang.Integer&nbsp;expires)</code></th>
<td class="colLast">
<div class="block">
 The time in seconds until the requested session expires.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setHLSFragmentSelector(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSFragmentSelector)">setHLSFragmentSelector</a></span>&#8203;(<a href="HLSFragmentSelector.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSFragmentSelector</a>&nbsp;hLSFragmentSelector)</code></th>
<td class="colLast">
<div class="block">
 The time range of the requested fragment and the source of the
 timestamps.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxMediaPlaylistFragmentResults(java.lang.Long)">setMaxMediaPlaylistFragmentResults</a></span>&#8203;(java.lang.Long&nbsp;maxMediaPlaylistFragmentResults)</code></th>
<td class="colLast">
<div class="block">
 The maximum number of fragments that are returned in the HLS media
 playlists.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPlaybackMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSPlaybackMode)">setPlaybackMode</a></span>&#8203;(<a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSPlaybackMode</a>&nbsp;playbackMode)</code></th>
<td class="colLast">
<div class="block">
 Whether to retrieve live, live replay, or archived, on-demand data.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPlaybackMode(java.lang.String)">setPlaybackMode</a></span>&#8203;(java.lang.String&nbsp;playbackMode)</code></th>
<td class="colLast">
<div class="block">
 Whether to retrieve live, live replay, or archived, on-demand data.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setStreamARN(java.lang.String)">setStreamARN</a></span>&#8203;(java.lang.String&nbsp;streamARN)</code></th>
<td class="colLast">
<div class="block">
 The Amazon Resource Name (ARN) of the stream for which to retrieve the
 HLS master playlist URL.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setStreamName(java.lang.String)">setStreamName</a></span>&#8203;(java.lang.String&nbsp;streamName)</code></th>
<td class="colLast">
<div class="block">
 The name of the stream for which to retrieve the HLS master playlist URL.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a string representation of this object; useful for testing and
 debugging.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withContainerFormat(com.amazonaws.services.kinesisvideoarchivedmedia.model.ContainerFormat)">withContainerFormat</a></span>&#8203;(<a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">ContainerFormat</a>&nbsp;containerFormat)</code></th>
<td class="colLast">
<div class="block">
 Specifies which format should be used for packaging the media.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withContainerFormat(java.lang.String)">withContainerFormat</a></span>&#8203;(java.lang.String&nbsp;containerFormat)</code></th>
<td class="colLast">
<div class="block">
 Specifies which format should be used for packaging the media.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withDiscontinuityMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDiscontinuityMode)">withDiscontinuityMode</a></span>&#8203;(<a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDiscontinuityMode</a>&nbsp;discontinuityMode)</code></th>
<td class="colLast">
<div class="block">
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withDiscontinuityMode(java.lang.String)">withDiscontinuityMode</a></span>&#8203;(java.lang.String&nbsp;discontinuityMode)</code></th>
<td class="colLast">
<div class="block">
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withDisplayFragmentTimestamp(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDisplayFragmentTimestamp)">withDisplayFragmentTimestamp</a></span>&#8203;(<a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDisplayFragmentTimestamp</a>&nbsp;displayFragmentTimestamp)</code></th>
<td class="colLast">
<div class="block">
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withDisplayFragmentTimestamp(java.lang.String)">withDisplayFragmentTimestamp</a></span>&#8203;(java.lang.String&nbsp;displayFragmentTimestamp)</code></th>
<td class="colLast">
<div class="block">
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withExpires(java.lang.Integer)">withExpires</a></span>&#8203;(java.lang.Integer&nbsp;expires)</code></th>
<td class="colLast">
<div class="block">
 The time in seconds until the requested session expires.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withHLSFragmentSelector(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSFragmentSelector)">withHLSFragmentSelector</a></span>&#8203;(<a href="HLSFragmentSelector.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSFragmentSelector</a>&nbsp;hLSFragmentSelector)</code></th>
<td class="colLast">
<div class="block">
 The time range of the requested fragment and the source of the
 timestamps.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withMaxMediaPlaylistFragmentResults(java.lang.Long)">withMaxMediaPlaylistFragmentResults</a></span>&#8203;(java.lang.Long&nbsp;maxMediaPlaylistFragmentResults)</code></th>
<td class="colLast">
<div class="block">
 The maximum number of fragments that are returned in the HLS media
 playlists.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withPlaybackMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSPlaybackMode)">withPlaybackMode</a></span>&#8203;(<a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSPlaybackMode</a>&nbsp;playbackMode)</code></th>
<td class="colLast">
<div class="block">
 Whether to retrieve live, live replay, or archived, on-demand data.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withPlaybackMode(java.lang.String)">withPlaybackMode</a></span>&#8203;(java.lang.String&nbsp;playbackMode)</code></th>
<td class="colLast">
<div class="block">
 Whether to retrieve live, live replay, or archived, on-demand data.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withStreamARN(java.lang.String)">withStreamARN</a></span>&#8203;(java.lang.String&nbsp;streamARN)</code></th>
<td class="colLast">
<div class="block">
 The Amazon Resource Name (ARN) of the stream for which to retrieve the
 HLS master playlist URL.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withStreamName(java.lang.String)">withStreamName</a></span>&#8203;(java.lang.String&nbsp;streamName)</code></th>
<td class="colLast">
<div class="block">
 The name of the stream for which to retrieve the HLS master playlist URL.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.amazonaws.AmazonWebServiceRequest">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;com.amazonaws.<a href="../../../AmazonWebServiceRequest.html" title="class in com.amazonaws">AmazonWebServiceRequest</a></h3>
<code><a href="../../../AmazonWebServiceRequest.html#clone()">clone</a>, <a href="../../../AmazonWebServiceRequest.html#getCloneRoot()">getCloneRoot</a>, <a href="../../../AmazonWebServiceRequest.html#getCloneSource()">getCloneSource</a>, <a href="../../../AmazonWebServiceRequest.html#getGeneralProgressListener()">getGeneralProgressListener</a>, <a href="../../../AmazonWebServiceRequest.html#getRequestClientOptions()">getRequestClientOptions</a>, <a href="../../../AmazonWebServiceRequest.html#getRequestCredentials()">getRequestCredentials</a>, <a href="../../../AmazonWebServiceRequest.html#getRequestMetricCollector()">getRequestMetricCollector</a>, <a href="../../../AmazonWebServiceRequest.html#setGeneralProgressListener(com.amazonaws.event.ProgressListener)">setGeneralProgressListener</a>, <a href="../../../AmazonWebServiceRequest.html#setRequestCredentials(com.amazonaws.auth.AWSCredentials)">setRequestCredentials</a>, <a href="../../../AmazonWebServiceRequest.html#setRequestMetricCollector(com.amazonaws.metrics.RequestMetricCollector)">setRequestMetricCollector</a>, <a href="../../../AmazonWebServiceRequest.html#withGeneralProgressListener(com.amazonaws.event.ProgressListener)">withGeneralProgressListener</a>, <a href="../../../AmazonWebServiceRequest.html#withRequestMetricCollector(com.amazonaws.metrics.RequestMetricCollector)">withRequestMetricCollector</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GetHLSStreamingSessionURLRequest</h4>
<pre>public&nbsp;GetHLSStreamingSessionURLRequest()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="getStreamName()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStreamName</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getStreamName()</pre>
<div class="block"><p>
 The name of the stream for which to retrieve the HLS master playlist URL.
 </p>
 <p>
 You must specify either the <code>StreamName</code> or the
 <code>StreamARN</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Length: </b>1 - 256<br/>
 <b>Pattern: </b>[a-zA-Z0-9_.-]+<br/></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         The name of the stream for which to retrieve the HLS master
         playlist URL.
         </p>
         <p>
         You must specify either the <code>StreamName</code> or the
         <code>StreamARN</code>.
         </p></dd>
</dl>
</li>
</ul>
<a id="setStreamName(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setStreamName</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setStreamName&#8203;(java.lang.String&nbsp;streamName)</pre>
<div class="block"><p>
 The name of the stream for which to retrieve the HLS master playlist URL.
 </p>
 <p>
 You must specify either the <code>StreamName</code> or the
 <code>StreamARN</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Length: </b>1 - 256<br/>
 <b>Pattern: </b>[a-zA-Z0-9_.-]+<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>streamName</code> - <p>
            The name of the stream for which to retrieve the HLS master
            playlist URL.
            </p>
            <p>
            You must specify either the <code>StreamName</code> or the
            <code>StreamARN</code>.
            </p></dd>
</dl>
</li>
</ul>
<a id="withStreamName(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withStreamName</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withStreamName&#8203;(java.lang.String&nbsp;streamName)</pre>
<div class="block"><p>
 The name of the stream for which to retrieve the HLS master playlist URL.
 </p>
 <p>
 You must specify either the <code>StreamName</code> or the
 <code>StreamARN</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Length: </b>1 - 256<br/>
 <b>Pattern: </b>[a-zA-Z0-9_.-]+<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>streamName</code> - <p>
            The name of the stream for which to retrieve the HLS master
            playlist URL.
            </p>
            <p>
            You must specify either the <code>StreamName</code> or the
            <code>StreamARN</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
</dl>
</li>
</ul>
<a id="getStreamARN()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStreamARN</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getStreamARN()</pre>
<div class="block"><p>
 The Amazon Resource Name (ARN) of the stream for which to retrieve the
 HLS master playlist URL.
 </p>
 <p>
 You must specify either the <code>StreamName</code> or the
 <code>StreamARN</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Length: </b>1 - 1024<br/>
 <b>Pattern:
 </b>arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-
 Z0-9_.-]+/[0-9]+<br/></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         The Amazon Resource Name (ARN) of the stream for which to
         retrieve the HLS master playlist URL.
         </p>
         <p>
         You must specify either the <code>StreamName</code> or the
         <code>StreamARN</code>.
         </p></dd>
</dl>
</li>
</ul>
<a id="setStreamARN(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setStreamARN</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setStreamARN&#8203;(java.lang.String&nbsp;streamARN)</pre>
<div class="block"><p>
 The Amazon Resource Name (ARN) of the stream for which to retrieve the
 HLS master playlist URL.
 </p>
 <p>
 You must specify either the <code>StreamName</code> or the
 <code>StreamARN</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Length: </b>1 - 1024<br/>
 <b>Pattern:
 </b>arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-
 Z0-9_.-]+/[0-9]+<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>streamARN</code> - <p>
            The Amazon Resource Name (ARN) of the stream for which to
            retrieve the HLS master playlist URL.
            </p>
            <p>
            You must specify either the <code>StreamName</code> or the
            <code>StreamARN</code>.
            </p></dd>
</dl>
</li>
</ul>
<a id="withStreamARN(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withStreamARN</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withStreamARN&#8203;(java.lang.String&nbsp;streamARN)</pre>
<div class="block"><p>
 The Amazon Resource Name (ARN) of the stream for which to retrieve the
 HLS master playlist URL.
 </p>
 <p>
 You must specify either the <code>StreamName</code> or the
 <code>StreamARN</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Length: </b>1 - 1024<br/>
 <b>Pattern:
 </b>arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-
 Z0-9_.-]+/[0-9]+<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>streamARN</code> - <p>
            The Amazon Resource Name (ARN) of the stream for which to
            retrieve the HLS master playlist URL.
            </p>
            <p>
            You must specify either the <code>StreamName</code> or the
            <code>StreamARN</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
</dl>
</li>
</ul>
<a id="getPlaybackMode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPlaybackMode</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getPlaybackMode()</pre>
<div class="block"><p>
 Whether to retrieve live, live replay, or archived, on-demand data.
 </p>
 <p>
 Features of the three types of sessions include the following:
 </p>
 <ul>
 <li>
 <p>
 <b> <code>LIVE</code> </b>: For sessions of this type, the HLS media
 playlist is continually updated with the latest fragments as they become
 available. We recommend that the media player retrieve a new playlist on
 a one-second interval. When this type of session is played in a media
 player, the user interface typically displays a "live" notification, with
 no scrubber control for choosing the position in the playback window to
 display.
 </p>
 <note>
 <p>
 In <code>LIVE</code> mode, the newest available fragments are included in
 an HLS media playlist, even if there is a gap between fragments (that is,
 if a fragment is missing). A gap like this might cause a media player to
 halt or cause a jump in playback. In this mode, fragments are not added
 to the HLS media playlist if they are older than the newest fragment in
 the playlist. If the missing fragment becomes available after a
 subsequent fragment is added to the playlist, the older fragment is not
 added, and the gap is not filled.
 </p>
 </note></li>
 <li>
 <p>
 <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type, the HLS
 media playlist is updated similarly to how it is updated for
 <code>LIVE</code> mode except that it starts by including fragments from
 a given start time. Instead of fragments being added as they are
 ingested, fragments are added as the duration of the next fragment
 elapses. For example, if the fragments in the session are two seconds
 long, then a new fragment is added to the media playlist every two
 seconds. This mode is useful to be able to start playback from when an
 event is detected and continue live streaming media that has not yet been
 ingested as of the time of the session creation. This mode is also useful
 to stream previously archived media without being limited by the 1,000
 fragment limit in the <code>ON_DEMAND</code> mode.
 </p>
 </li>
 <li>
 <p>
 <b> <code>ON_DEMAND</code> </b>: For sessions of this type, the HLS media
 playlist contains all the fragments for the session, up to the number
 that is specified in <code>MaxMediaPlaylistFragmentResults</code>. The
 playlist must be retrieved only once for each session. When this type of
 session is played in a media player, the user interface typically
 displays a scrubber control for choosing the position in the playback
 window to display.
 </p>
 </li>
 </ul>
 <p>
 In all playback modes, if <code>FragmentSelectorType</code> is
 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with
 the same start timestamp, the fragment that has the largest fragment
 number (that is, the newest fragment) is included in the HLS media
 playlist. The other fragments are not included. Fragments that have
 different timestamps but have overlapping durations are still included in
 the HLS media playlist. This can lead to unexpected behavior in the media
 player.
 </p>
 <p>
 The default is <code>LIVE</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>LIVE, LIVE_REPLAY, ON_DEMAND</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         Whether to retrieve live, live replay, or archived, on-demand
         data.
         </p>
         <p>
         Features of the three types of sessions include the following:
         </p>
         <ul>
         <li>
         <p>
         <b> <code>LIVE</code> </b>: For sessions of this type, the HLS
         media playlist is continually updated with the latest fragments
         as they become available. We recommend that the media player
         retrieve a new playlist on a one-second interval. When this type
         of session is played in a media player, the user interface
         typically displays a "live" notification, with no scrubber
         control for choosing the position in the playback window to
         display.
         </p>
         <note>
         <p>
         In <code>LIVE</code> mode, the newest available fragments are
         included in an HLS media playlist, even if there is a gap between
         fragments (that is, if a fragment is missing). A gap like this
         might cause a media player to halt or cause a jump in playback.
         In this mode, fragments are not added to the HLS media playlist
         if they are older than the newest fragment in the playlist. If
         the missing fragment becomes available after a subsequent
         fragment is added to the playlist, the older fragment is not
         added, and the gap is not filled.
         </p>
         </note></li>
         <li>
         <p>
         <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type, the
         HLS media playlist is updated similarly to how it is updated for
         <code>LIVE</code> mode except that it starts by including
         fragments from a given start time. Instead of fragments being
         added as they are ingested, fragments are added as the duration
         of the next fragment elapses. For example, if the fragments in
         the session are two seconds long, then a new fragment is added to
         the media playlist every two seconds. This mode is useful to be
         able to start playback from when an event is detected and
         continue live streaming media that has not yet been ingested as
         of the time of the session creation. This mode is also useful to
         stream previously archived media without being limited by the
         1,000 fragment limit in the <code>ON_DEMAND</code> mode.
         </p>
         </li>
         <li>
         <p>
         <b> <code>ON_DEMAND</code> </b>: For sessions of this type, the
         HLS media playlist contains all the fragments for the session, up
         to the number that is specified in
         <code>MaxMediaPlaylistFragmentResults</code>. The playlist must
         be retrieved only once for each session. When this type of
         session is played in a media player, the user interface typically
         displays a scrubber control for choosing the position in the
         playback window to display.
         </p>
         </li>
         </ul>
         <p>
         In all playback modes, if <code>FragmentSelectorType</code> is
         <code>PRODUCER_TIMESTAMP</code>, and if there are multiple
         fragments with the same start timestamp, the fragment that has
         the largest fragment number (that is, the newest fragment) is
         included in the HLS media playlist. The other fragments are not
         included. Fragments that have different timestamps but have
         overlapping durations are still included in the HLS media
         playlist. This can lead to unexpected behavior in the media
         player.
         </p>
         <p>
         The default is <code>LIVE</code>.
         </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSPlaybackMode</code></a></dd>
</dl>
</li>
</ul>
<a id="setPlaybackMode(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPlaybackMode</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setPlaybackMode&#8203;(java.lang.String&nbsp;playbackMode)</pre>
<div class="block"><p>
 Whether to retrieve live, live replay, or archived, on-demand data.
 </p>
 <p>
 Features of the three types of sessions include the following:
 </p>
 <ul>
 <li>
 <p>
 <b> <code>LIVE</code> </b>: For sessions of this type, the HLS media
 playlist is continually updated with the latest fragments as they become
 available. We recommend that the media player retrieve a new playlist on
 a one-second interval. When this type of session is played in a media
 player, the user interface typically displays a "live" notification, with
 no scrubber control for choosing the position in the playback window to
 display.
 </p>
 <note>
 <p>
 In <code>LIVE</code> mode, the newest available fragments are included in
 an HLS media playlist, even if there is a gap between fragments (that is,
 if a fragment is missing). A gap like this might cause a media player to
 halt or cause a jump in playback. In this mode, fragments are not added
 to the HLS media playlist if they are older than the newest fragment in
 the playlist. If the missing fragment becomes available after a
 subsequent fragment is added to the playlist, the older fragment is not
 added, and the gap is not filled.
 </p>
 </note></li>
 <li>
 <p>
 <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type, the HLS
 media playlist is updated similarly to how it is updated for
 <code>LIVE</code> mode except that it starts by including fragments from
 a given start time. Instead of fragments being added as they are
 ingested, fragments are added as the duration of the next fragment
 elapses. For example, if the fragments in the session are two seconds
 long, then a new fragment is added to the media playlist every two
 seconds. This mode is useful to be able to start playback from when an
 event is detected and continue live streaming media that has not yet been
 ingested as of the time of the session creation. This mode is also useful
 to stream previously archived media without being limited by the 1,000
 fragment limit in the <code>ON_DEMAND</code> mode.
 </p>
 </li>
 <li>
 <p>
 <b> <code>ON_DEMAND</code> </b>: For sessions of this type, the HLS media
 playlist contains all the fragments for the session, up to the number
 that is specified in <code>MaxMediaPlaylistFragmentResults</code>. The
 playlist must be retrieved only once for each session. When this type of
 session is played in a media player, the user interface typically
 displays a scrubber control for choosing the position in the playback
 window to display.
 </p>
 </li>
 </ul>
 <p>
 In all playback modes, if <code>FragmentSelectorType</code> is
 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with
 the same start timestamp, the fragment that has the largest fragment
 number (that is, the newest fragment) is included in the HLS media
 playlist. The other fragments are not included. Fragments that have
 different timestamps but have overlapping durations are still included in
 the HLS media playlist. This can lead to unexpected behavior in the media
 player.
 </p>
 <p>
 The default is <code>LIVE</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>LIVE, LIVE_REPLAY, ON_DEMAND</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>playbackMode</code> - <p>
            Whether to retrieve live, live replay, or archived, on-demand
            data.
            </p>
            <p>
            Features of the three types of sessions include the following:
            </p>
            <ul>
            <li>
            <p>
            <b> <code>LIVE</code> </b>: For sessions of this type, the HLS
            media playlist is continually updated with the latest
            fragments as they become available. We recommend that the
            media player retrieve a new playlist on a one-second interval.
            When this type of session is played in a media player, the
            user interface typically displays a "live" notification, with
            no scrubber control for choosing the position in the playback
            window to display.
            </p>
            <note>
            <p>
            In <code>LIVE</code> mode, the newest available fragments are
            included in an HLS media playlist, even if there is a gap
            between fragments (that is, if a fragment is missing). A gap
            like this might cause a media player to halt or cause a jump
            in playback. In this mode, fragments are not added to the HLS
            media playlist if they are older than the newest fragment in
            the playlist. If the missing fragment becomes available after
            a subsequent fragment is added to the playlist, the older
            fragment is not added, and the gap is not filled.
            </p>
            </note></li>
            <li>
            <p>
            <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type,
            the HLS media playlist is updated similarly to how it is
            updated for <code>LIVE</code> mode except that it starts by
            including fragments from a given start time. Instead of
            fragments being added as they are ingested, fragments are
            added as the duration of the next fragment elapses. For
            example, if the fragments in the session are two seconds long,
            then a new fragment is added to the media playlist every two
            seconds. This mode is useful to be able to start playback from
            when an event is detected and continue live streaming media
            that has not yet been ingested as of the time of the session
            creation. This mode is also useful to stream previously
            archived media without being limited by the 1,000 fragment
            limit in the <code>ON_DEMAND</code> mode.
            </p>
            </li>
            <li>
            <p>
            <b> <code>ON_DEMAND</code> </b>: For sessions of this type,
            the HLS media playlist contains all the fragments for the
            session, up to the number that is specified in
            <code>MaxMediaPlaylistFragmentResults</code>. The playlist
            must be retrieved only once for each session. When this type
            of session is played in a media player, the user interface
            typically displays a scrubber control for choosing the
            position in the playback window to display.
            </p>
            </li>
            </ul>
            <p>
            In all playback modes, if <code>FragmentSelectorType</code> is
            <code>PRODUCER_TIMESTAMP</code>, and if there are multiple
            fragments with the same start timestamp, the fragment that has
            the largest fragment number (that is, the newest fragment) is
            included in the HLS media playlist. The other fragments are
            not included. Fragments that have different timestamps but
            have overlapping durations are still included in the HLS media
            playlist. This can lead to unexpected behavior in the media
            player.
            </p>
            <p>
            The default is <code>LIVE</code>.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSPlaybackMode</code></a></dd>
</dl>
</li>
</ul>
<a id="withPlaybackMode(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withPlaybackMode</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withPlaybackMode&#8203;(java.lang.String&nbsp;playbackMode)</pre>
<div class="block"><p>
 Whether to retrieve live, live replay, or archived, on-demand data.
 </p>
 <p>
 Features of the three types of sessions include the following:
 </p>
 <ul>
 <li>
 <p>
 <b> <code>LIVE</code> </b>: For sessions of this type, the HLS media
 playlist is continually updated with the latest fragments as they become
 available. We recommend that the media player retrieve a new playlist on
 a one-second interval. When this type of session is played in a media
 player, the user interface typically displays a "live" notification, with
 no scrubber control for choosing the position in the playback window to
 display.
 </p>
 <note>
 <p>
 In <code>LIVE</code> mode, the newest available fragments are included in
 an HLS media playlist, even if there is a gap between fragments (that is,
 if a fragment is missing). A gap like this might cause a media player to
 halt or cause a jump in playback. In this mode, fragments are not added
 to the HLS media playlist if they are older than the newest fragment in
 the playlist. If the missing fragment becomes available after a
 subsequent fragment is added to the playlist, the older fragment is not
 added, and the gap is not filled.
 </p>
 </note></li>
 <li>
 <p>
 <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type, the HLS
 media playlist is updated similarly to how it is updated for
 <code>LIVE</code> mode except that it starts by including fragments from
 a given start time. Instead of fragments being added as they are
 ingested, fragments are added as the duration of the next fragment
 elapses. For example, if the fragments in the session are two seconds
 long, then a new fragment is added to the media playlist every two
 seconds. This mode is useful to be able to start playback from when an
 event is detected and continue live streaming media that has not yet been
 ingested as of the time of the session creation. This mode is also useful
 to stream previously archived media without being limited by the 1,000
 fragment limit in the <code>ON_DEMAND</code> mode.
 </p>
 </li>
 <li>
 <p>
 <b> <code>ON_DEMAND</code> </b>: For sessions of this type, the HLS media
 playlist contains all the fragments for the session, up to the number
 that is specified in <code>MaxMediaPlaylistFragmentResults</code>. The
 playlist must be retrieved only once for each session. When this type of
 session is played in a media player, the user interface typically
 displays a scrubber control for choosing the position in the playback
 window to display.
 </p>
 </li>
 </ul>
 <p>
 In all playback modes, if <code>FragmentSelectorType</code> is
 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with
 the same start timestamp, the fragment that has the largest fragment
 number (that is, the newest fragment) is included in the HLS media
 playlist. The other fragments are not included. Fragments that have
 different timestamps but have overlapping durations are still included in
 the HLS media playlist. This can lead to unexpected behavior in the media
 player.
 </p>
 <p>
 The default is <code>LIVE</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>LIVE, LIVE_REPLAY, ON_DEMAND</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>playbackMode</code> - <p>
            Whether to retrieve live, live replay, or archived, on-demand
            data.
            </p>
            <p>
            Features of the three types of sessions include the following:
            </p>
            <ul>
            <li>
            <p>
            <b> <code>LIVE</code> </b>: For sessions of this type, the HLS
            media playlist is continually updated with the latest
            fragments as they become available. We recommend that the
            media player retrieve a new playlist on a one-second interval.
            When this type of session is played in a media player, the
            user interface typically displays a "live" notification, with
            no scrubber control for choosing the position in the playback
            window to display.
            </p>
            <note>
            <p>
            In <code>LIVE</code> mode, the newest available fragments are
            included in an HLS media playlist, even if there is a gap
            between fragments (that is, if a fragment is missing). A gap
            like this might cause a media player to halt or cause a jump
            in playback. In this mode, fragments are not added to the HLS
            media playlist if they are older than the newest fragment in
            the playlist. If the missing fragment becomes available after
            a subsequent fragment is added to the playlist, the older
            fragment is not added, and the gap is not filled.
            </p>
            </note></li>
            <li>
            <p>
            <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type,
            the HLS media playlist is updated similarly to how it is
            updated for <code>LIVE</code> mode except that it starts by
            including fragments from a given start time. Instead of
            fragments being added as they are ingested, fragments are
            added as the duration of the next fragment elapses. For
            example, if the fragments in the session are two seconds long,
            then a new fragment is added to the media playlist every two
            seconds. This mode is useful to be able to start playback from
            when an event is detected and continue live streaming media
            that has not yet been ingested as of the time of the session
            creation. This mode is also useful to stream previously
            archived media without being limited by the 1,000 fragment
            limit in the <code>ON_DEMAND</code> mode.
            </p>
            </li>
            <li>
            <p>
            <b> <code>ON_DEMAND</code> </b>: For sessions of this type,
            the HLS media playlist contains all the fragments for the
            session, up to the number that is specified in
            <code>MaxMediaPlaylistFragmentResults</code>. The playlist
            must be retrieved only once for each session. When this type
            of session is played in a media player, the user interface
            typically displays a scrubber control for choosing the
            position in the playback window to display.
            </p>
            </li>
            </ul>
            <p>
            In all playback modes, if <code>FragmentSelectorType</code> is
            <code>PRODUCER_TIMESTAMP</code>, and if there are multiple
            fragments with the same start timestamp, the fragment that has
            the largest fragment number (that is, the newest fragment) is
            included in the HLS media playlist. The other fragments are
            not included. Fragments that have different timestamps but
            have overlapping durations are still included in the HLS media
            playlist. This can lead to unexpected behavior in the media
            player.
            </p>
            <p>
            The default is <code>LIVE</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSPlaybackMode</code></a></dd>
</dl>
</li>
</ul>
<a id="setPlaybackMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSPlaybackMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPlaybackMode</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setPlaybackMode&#8203;(<a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSPlaybackMode</a>&nbsp;playbackMode)</pre>
<div class="block"><p>
 Whether to retrieve live, live replay, or archived, on-demand data.
 </p>
 <p>
 Features of the three types of sessions include the following:
 </p>
 <ul>
 <li>
 <p>
 <b> <code>LIVE</code> </b>: For sessions of this type, the HLS media
 playlist is continually updated with the latest fragments as they become
 available. We recommend that the media player retrieve a new playlist on
 a one-second interval. When this type of session is played in a media
 player, the user interface typically displays a "live" notification, with
 no scrubber control for choosing the position in the playback window to
 display.
 </p>
 <note>
 <p>
 In <code>LIVE</code> mode, the newest available fragments are included in
 an HLS media playlist, even if there is a gap between fragments (that is,
 if a fragment is missing). A gap like this might cause a media player to
 halt or cause a jump in playback. In this mode, fragments are not added
 to the HLS media playlist if they are older than the newest fragment in
 the playlist. If the missing fragment becomes available after a
 subsequent fragment is added to the playlist, the older fragment is not
 added, and the gap is not filled.
 </p>
 </note></li>
 <li>
 <p>
 <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type, the HLS
 media playlist is updated similarly to how it is updated for
 <code>LIVE</code> mode except that it starts by including fragments from
 a given start time. Instead of fragments being added as they are
 ingested, fragments are added as the duration of the next fragment
 elapses. For example, if the fragments in the session are two seconds
 long, then a new fragment is added to the media playlist every two
 seconds. This mode is useful to be able to start playback from when an
 event is detected and continue live streaming media that has not yet been
 ingested as of the time of the session creation. This mode is also useful
 to stream previously archived media without being limited by the 1,000
 fragment limit in the <code>ON_DEMAND</code> mode.
 </p>
 </li>
 <li>
 <p>
 <b> <code>ON_DEMAND</code> </b>: For sessions of this type, the HLS media
 playlist contains all the fragments for the session, up to the number
 that is specified in <code>MaxMediaPlaylistFragmentResults</code>. The
 playlist must be retrieved only once for each session. When this type of
 session is played in a media player, the user interface typically
 displays a scrubber control for choosing the position in the playback
 window to display.
 </p>
 </li>
 </ul>
 <p>
 In all playback modes, if <code>FragmentSelectorType</code> is
 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with
 the same start timestamp, the fragment that has the largest fragment
 number (that is, the newest fragment) is included in the HLS media
 playlist. The other fragments are not included. Fragments that have
 different timestamps but have overlapping durations are still included in
 the HLS media playlist. This can lead to unexpected behavior in the media
 player.
 </p>
 <p>
 The default is <code>LIVE</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>LIVE, LIVE_REPLAY, ON_DEMAND</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>playbackMode</code> - <p>
            Whether to retrieve live, live replay, or archived, on-demand
            data.
            </p>
            <p>
            Features of the three types of sessions include the following:
            </p>
            <ul>
            <li>
            <p>
            <b> <code>LIVE</code> </b>: For sessions of this type, the HLS
            media playlist is continually updated with the latest
            fragments as they become available. We recommend that the
            media player retrieve a new playlist on a one-second interval.
            When this type of session is played in a media player, the
            user interface typically displays a "live" notification, with
            no scrubber control for choosing the position in the playback
            window to display.
            </p>
            <note>
            <p>
            In <code>LIVE</code> mode, the newest available fragments are
            included in an HLS media playlist, even if there is a gap
            between fragments (that is, if a fragment is missing). A gap
            like this might cause a media player to halt or cause a jump
            in playback. In this mode, fragments are not added to the HLS
            media playlist if they are older than the newest fragment in
            the playlist. If the missing fragment becomes available after
            a subsequent fragment is added to the playlist, the older
            fragment is not added, and the gap is not filled.
            </p>
            </note></li>
            <li>
            <p>
            <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type,
            the HLS media playlist is updated similarly to how it is
            updated for <code>LIVE</code> mode except that it starts by
            including fragments from a given start time. Instead of
            fragments being added as they are ingested, fragments are
            added as the duration of the next fragment elapses. For
            example, if the fragments in the session are two seconds long,
            then a new fragment is added to the media playlist every two
            seconds. This mode is useful to be able to start playback from
            when an event is detected and continue live streaming media
            that has not yet been ingested as of the time of the session
            creation. This mode is also useful to stream previously
            archived media without being limited by the 1,000 fragment
            limit in the <code>ON_DEMAND</code> mode.
            </p>
            </li>
            <li>
            <p>
            <b> <code>ON_DEMAND</code> </b>: For sessions of this type,
            the HLS media playlist contains all the fragments for the
            session, up to the number that is specified in
            <code>MaxMediaPlaylistFragmentResults</code>. The playlist
            must be retrieved only once for each session. When this type
            of session is played in a media player, the user interface
            typically displays a scrubber control for choosing the
            position in the playback window to display.
            </p>
            </li>
            </ul>
            <p>
            In all playback modes, if <code>FragmentSelectorType</code> is
            <code>PRODUCER_TIMESTAMP</code>, and if there are multiple
            fragments with the same start timestamp, the fragment that has
            the largest fragment number (that is, the newest fragment) is
            included in the HLS media playlist. The other fragments are
            not included. Fragments that have different timestamps but
            have overlapping durations are still included in the HLS media
            playlist. This can lead to unexpected behavior in the media
            player.
            </p>
            <p>
            The default is <code>LIVE</code>.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSPlaybackMode</code></a></dd>
</dl>
</li>
</ul>
<a id="withPlaybackMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSPlaybackMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withPlaybackMode</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withPlaybackMode&#8203;(<a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSPlaybackMode</a>&nbsp;playbackMode)</pre>
<div class="block"><p>
 Whether to retrieve live, live replay, or archived, on-demand data.
 </p>
 <p>
 Features of the three types of sessions include the following:
 </p>
 <ul>
 <li>
 <p>
 <b> <code>LIVE</code> </b>: For sessions of this type, the HLS media
 playlist is continually updated with the latest fragments as they become
 available. We recommend that the media player retrieve a new playlist on
 a one-second interval. When this type of session is played in a media
 player, the user interface typically displays a "live" notification, with
 no scrubber control for choosing the position in the playback window to
 display.
 </p>
 <note>
 <p>
 In <code>LIVE</code> mode, the newest available fragments are included in
 an HLS media playlist, even if there is a gap between fragments (that is,
 if a fragment is missing). A gap like this might cause a media player to
 halt or cause a jump in playback. In this mode, fragments are not added
 to the HLS media playlist if they are older than the newest fragment in
 the playlist. If the missing fragment becomes available after a
 subsequent fragment is added to the playlist, the older fragment is not
 added, and the gap is not filled.
 </p>
 </note></li>
 <li>
 <p>
 <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type, the HLS
 media playlist is updated similarly to how it is updated for
 <code>LIVE</code> mode except that it starts by including fragments from
 a given start time. Instead of fragments being added as they are
 ingested, fragments are added as the duration of the next fragment
 elapses. For example, if the fragments in the session are two seconds
 long, then a new fragment is added to the media playlist every two
 seconds. This mode is useful to be able to start playback from when an
 event is detected and continue live streaming media that has not yet been
 ingested as of the time of the session creation. This mode is also useful
 to stream previously archived media without being limited by the 1,000
 fragment limit in the <code>ON_DEMAND</code> mode.
 </p>
 </li>
 <li>
 <p>
 <b> <code>ON_DEMAND</code> </b>: For sessions of this type, the HLS media
 playlist contains all the fragments for the session, up to the number
 that is specified in <code>MaxMediaPlaylistFragmentResults</code>. The
 playlist must be retrieved only once for each session. When this type of
 session is played in a media player, the user interface typically
 displays a scrubber control for choosing the position in the playback
 window to display.
 </p>
 </li>
 </ul>
 <p>
 In all playback modes, if <code>FragmentSelectorType</code> is
 <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with
 the same start timestamp, the fragment that has the largest fragment
 number (that is, the newest fragment) is included in the HLS media
 playlist. The other fragments are not included. Fragments that have
 different timestamps but have overlapping durations are still included in
 the HLS media playlist. This can lead to unexpected behavior in the media
 player.
 </p>
 <p>
 The default is <code>LIVE</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>LIVE, LIVE_REPLAY, ON_DEMAND</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>playbackMode</code> - <p>
            Whether to retrieve live, live replay, or archived, on-demand
            data.
            </p>
            <p>
            Features of the three types of sessions include the following:
            </p>
            <ul>
            <li>
            <p>
            <b> <code>LIVE</code> </b>: For sessions of this type, the HLS
            media playlist is continually updated with the latest
            fragments as they become available. We recommend that the
            media player retrieve a new playlist on a one-second interval.
            When this type of session is played in a media player, the
            user interface typically displays a "live" notification, with
            no scrubber control for choosing the position in the playback
            window to display.
            </p>
            <note>
            <p>
            In <code>LIVE</code> mode, the newest available fragments are
            included in an HLS media playlist, even if there is a gap
            between fragments (that is, if a fragment is missing). A gap
            like this might cause a media player to halt or cause a jump
            in playback. In this mode, fragments are not added to the HLS
            media playlist if they are older than the newest fragment in
            the playlist. If the missing fragment becomes available after
            a subsequent fragment is added to the playlist, the older
            fragment is not added, and the gap is not filled.
            </p>
            </note></li>
            <li>
            <p>
            <b> <code>LIVE_REPLAY</code> </b>: For sessions of this type,
            the HLS media playlist is updated similarly to how it is
            updated for <code>LIVE</code> mode except that it starts by
            including fragments from a given start time. Instead of
            fragments being added as they are ingested, fragments are
            added as the duration of the next fragment elapses. For
            example, if the fragments in the session are two seconds long,
            then a new fragment is added to the media playlist every two
            seconds. This mode is useful to be able to start playback from
            when an event is detected and continue live streaming media
            that has not yet been ingested as of the time of the session
            creation. This mode is also useful to stream previously
            archived media without being limited by the 1,000 fragment
            limit in the <code>ON_DEMAND</code> mode.
            </p>
            </li>
            <li>
            <p>
            <b> <code>ON_DEMAND</code> </b>: For sessions of this type,
            the HLS media playlist contains all the fragments for the
            session, up to the number that is specified in
            <code>MaxMediaPlaylistFragmentResults</code>. The playlist
            must be retrieved only once for each session. When this type
            of session is played in a media player, the user interface
            typically displays a scrubber control for choosing the
            position in the playback window to display.
            </p>
            </li>
            </ul>
            <p>
            In all playback modes, if <code>FragmentSelectorType</code> is
            <code>PRODUCER_TIMESTAMP</code>, and if there are multiple
            fragments with the same start timestamp, the fragment that has
            the largest fragment number (that is, the newest fragment) is
            included in the HLS media playlist. The other fragments are
            not included. Fragments that have different timestamps but
            have overlapping durations are still included in the HLS media
            playlist. This can lead to unexpected behavior in the media
            player.
            </p>
            <p>
            The default is <code>LIVE</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSPlaybackMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSPlaybackMode</code></a></dd>
</dl>
</li>
</ul>
<a id="getHLSFragmentSelector()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHLSFragmentSelector</h4>
<pre class="methodSignature">public&nbsp;<a href="HLSFragmentSelector.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSFragmentSelector</a>&nbsp;getHLSFragmentSelector()</pre>
<div class="block"><p>
 The time range of the requested fragment and the source of the
 timestamps.
 </p>
 <p>
 This parameter is required if <code>PlaybackMode</code> is
 <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>. This parameter is
 optional if PlaybackMode is<code/> <code>LIVE</code>. If
 <code>PlaybackMode</code> is <code>LIVE</code>, the
 <code>FragmentSelectorType</code> can be set, but the
 <code>TimestampRange</code> should not be set. If
 <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
 <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
 <code>TimestampRange</code> must be set.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         The time range of the requested fragment and the source of the
         timestamps.
         </p>
         <p>
         This parameter is required if <code>PlaybackMode</code> is
         <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>. This
         parameter is optional if PlaybackMode is<code/> <code>LIVE</code>
         . If <code>PlaybackMode</code> is <code>LIVE</code>, the
         <code>FragmentSelectorType</code> can be set, but the
         <code>TimestampRange</code> should not be set. If
         <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
         <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code>
         and <code>TimestampRange</code> must be set.
         </p></dd>
</dl>
</li>
</ul>
<a id="setHLSFragmentSelector(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSFragmentSelector)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setHLSFragmentSelector</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setHLSFragmentSelector&#8203;(<a href="HLSFragmentSelector.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSFragmentSelector</a>&nbsp;hLSFragmentSelector)</pre>
<div class="block"><p>
 The time range of the requested fragment and the source of the
 timestamps.
 </p>
 <p>
 This parameter is required if <code>PlaybackMode</code> is
 <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>. This parameter is
 optional if PlaybackMode is<code/> <code>LIVE</code>. If
 <code>PlaybackMode</code> is <code>LIVE</code>, the
 <code>FragmentSelectorType</code> can be set, but the
 <code>TimestampRange</code> should not be set. If
 <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
 <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
 <code>TimestampRange</code> must be set.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hLSFragmentSelector</code> - <p>
            The time range of the requested fragment and the source of the
            timestamps.
            </p>
            <p>
            This parameter is required if <code>PlaybackMode</code> is
            <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>. This
            parameter is optional if PlaybackMode is
            <code/> <code>LIVE</code>. If <code>PlaybackMode</code> is
            <code>LIVE</code>, the <code>FragmentSelectorType</code> can
            be set, but the <code>TimestampRange</code> should not be set.
            If <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
            <code>LIVE_REPLAY</code>, both
            <code>FragmentSelectorType</code> and
            <code>TimestampRange</code> must be set.
            </p></dd>
</dl>
</li>
</ul>
<a id="withHLSFragmentSelector(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSFragmentSelector)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withHLSFragmentSelector</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withHLSFragmentSelector&#8203;(<a href="HLSFragmentSelector.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSFragmentSelector</a>&nbsp;hLSFragmentSelector)</pre>
<div class="block"><p>
 The time range of the requested fragment and the source of the
 timestamps.
 </p>
 <p>
 This parameter is required if <code>PlaybackMode</code> is
 <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>. This parameter is
 optional if PlaybackMode is<code/> <code>LIVE</code>. If
 <code>PlaybackMode</code> is <code>LIVE</code>, the
 <code>FragmentSelectorType</code> can be set, but the
 <code>TimestampRange</code> should not be set. If
 <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
 <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
 <code>TimestampRange</code> must be set.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hLSFragmentSelector</code> - <p>
            The time range of the requested fragment and the source of the
            timestamps.
            </p>
            <p>
            This parameter is required if <code>PlaybackMode</code> is
            <code>ON_DEMAND</code> or <code>LIVE_REPLAY</code>. This
            parameter is optional if PlaybackMode is
            <code/> <code>LIVE</code>. If <code>PlaybackMode</code> is
            <code>LIVE</code>, the <code>FragmentSelectorType</code> can
            be set, but the <code>TimestampRange</code> should not be set.
            If <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
            <code>LIVE_REPLAY</code>, both
            <code>FragmentSelectorType</code> and
            <code>TimestampRange</code> must be set.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
</dl>
</li>
</ul>
<a id="getContainerFormat()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContainerFormat</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getContainerFormat()</pre>
<div class="block"><p>
 Specifies which format should be used for packaging the media. Specifying
 the <code>FRAGMENTED_MP4</code> container format packages the media into
 MP4 fragments (fMP4 or CMAF). This is the recommended packaging because
 there is minimal packaging overhead. The other container format option is
 <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since it was
 released and is sometimes the only supported packaging on older HLS
 players. MPEG TS typically has a 5-25 percent packaging overhead. This
 means MPEG TS typically requires 5-25 percent more bandwidth and cost
 than fMP4.
 </p>
 <p>
 The default is <code>FRAGMENTED_MP4</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>FRAGMENTED_MP4, MPEG_TS</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         Specifies which format should be used for packaging the media.
         Specifying the <code>FRAGMENTED_MP4</code> container format
         packages the media into MP4 fragments (fMP4 or CMAF). This is the
         recommended packaging because there is minimal packaging
         overhead. The other container format option is
         <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since it
         was released and is sometimes the only supported packaging on
         older HLS players. MPEG TS typically has a 5-25 percent packaging
         overhead. This means MPEG TS typically requires 5-25 percent more
         bandwidth and cost than fMP4.
         </p>
         <p>
         The default is <code>FRAGMENTED_MP4</code>.
         </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>ContainerFormat</code></a></dd>
</dl>
</li>
</ul>
<a id="setContainerFormat(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setContainerFormat</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setContainerFormat&#8203;(java.lang.String&nbsp;containerFormat)</pre>
<div class="block"><p>
 Specifies which format should be used for packaging the media. Specifying
 the <code>FRAGMENTED_MP4</code> container format packages the media into
 MP4 fragments (fMP4 or CMAF). This is the recommended packaging because
 there is minimal packaging overhead. The other container format option is
 <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since it was
 released and is sometimes the only supported packaging on older HLS
 players. MPEG TS typically has a 5-25 percent packaging overhead. This
 means MPEG TS typically requires 5-25 percent more bandwidth and cost
 than fMP4.
 </p>
 <p>
 The default is <code>FRAGMENTED_MP4</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>FRAGMENTED_MP4, MPEG_TS</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>containerFormat</code> - <p>
            Specifies which format should be used for packaging the media.
            Specifying the <code>FRAGMENTED_MP4</code> container format
            packages the media into MP4 fragments (fMP4 or CMAF). This is
            the recommended packaging because there is minimal packaging
            overhead. The other container format option is
            <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since
            it was released and is sometimes the only supported packaging
            on older HLS players. MPEG TS typically has a 5-25 percent
            packaging overhead. This means MPEG TS typically requires 5-25
            percent more bandwidth and cost than fMP4.
            </p>
            <p>
            The default is <code>FRAGMENTED_MP4</code>.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>ContainerFormat</code></a></dd>
</dl>
</li>
</ul>
<a id="withContainerFormat(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withContainerFormat</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withContainerFormat&#8203;(java.lang.String&nbsp;containerFormat)</pre>
<div class="block"><p>
 Specifies which format should be used for packaging the media. Specifying
 the <code>FRAGMENTED_MP4</code> container format packages the media into
 MP4 fragments (fMP4 or CMAF). This is the recommended packaging because
 there is minimal packaging overhead. The other container format option is
 <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since it was
 released and is sometimes the only supported packaging on older HLS
 players. MPEG TS typically has a 5-25 percent packaging overhead. This
 means MPEG TS typically requires 5-25 percent more bandwidth and cost
 than fMP4.
 </p>
 <p>
 The default is <code>FRAGMENTED_MP4</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>FRAGMENTED_MP4, MPEG_TS</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>containerFormat</code> - <p>
            Specifies which format should be used for packaging the media.
            Specifying the <code>FRAGMENTED_MP4</code> container format
            packages the media into MP4 fragments (fMP4 or CMAF). This is
            the recommended packaging because there is minimal packaging
            overhead. The other container format option is
            <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since
            it was released and is sometimes the only supported packaging
            on older HLS players. MPEG TS typically has a 5-25 percent
            packaging overhead. This means MPEG TS typically requires 5-25
            percent more bandwidth and cost than fMP4.
            </p>
            <p>
            The default is <code>FRAGMENTED_MP4</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>ContainerFormat</code></a></dd>
</dl>
</li>
</ul>
<a id="setContainerFormat(com.amazonaws.services.kinesisvideoarchivedmedia.model.ContainerFormat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setContainerFormat</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setContainerFormat&#8203;(<a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">ContainerFormat</a>&nbsp;containerFormat)</pre>
<div class="block"><p>
 Specifies which format should be used for packaging the media. Specifying
 the <code>FRAGMENTED_MP4</code> container format packages the media into
 MP4 fragments (fMP4 or CMAF). This is the recommended packaging because
 there is minimal packaging overhead. The other container format option is
 <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since it was
 released and is sometimes the only supported packaging on older HLS
 players. MPEG TS typically has a 5-25 percent packaging overhead. This
 means MPEG TS typically requires 5-25 percent more bandwidth and cost
 than fMP4.
 </p>
 <p>
 The default is <code>FRAGMENTED_MP4</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>FRAGMENTED_MP4, MPEG_TS</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>containerFormat</code> - <p>
            Specifies which format should be used for packaging the media.
            Specifying the <code>FRAGMENTED_MP4</code> container format
            packages the media into MP4 fragments (fMP4 or CMAF). This is
            the recommended packaging because there is minimal packaging
            overhead. The other container format option is
            <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since
            it was released and is sometimes the only supported packaging
            on older HLS players. MPEG TS typically has a 5-25 percent
            packaging overhead. This means MPEG TS typically requires 5-25
            percent more bandwidth and cost than fMP4.
            </p>
            <p>
            The default is <code>FRAGMENTED_MP4</code>.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>ContainerFormat</code></a></dd>
</dl>
</li>
</ul>
<a id="withContainerFormat(com.amazonaws.services.kinesisvideoarchivedmedia.model.ContainerFormat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withContainerFormat</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withContainerFormat&#8203;(<a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">ContainerFormat</a>&nbsp;containerFormat)</pre>
<div class="block"><p>
 Specifies which format should be used for packaging the media. Specifying
 the <code>FRAGMENTED_MP4</code> container format packages the media into
 MP4 fragments (fMP4 or CMAF). This is the recommended packaging because
 there is minimal packaging overhead. The other container format option is
 <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since it was
 released and is sometimes the only supported packaging on older HLS
 players. MPEG TS typically has a 5-25 percent packaging overhead. This
 means MPEG TS typically requires 5-25 percent more bandwidth and cost
 than fMP4.
 </p>
 <p>
 The default is <code>FRAGMENTED_MP4</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>FRAGMENTED_MP4, MPEG_TS</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>containerFormat</code> - <p>
            Specifies which format should be used for packaging the media.
            Specifying the <code>FRAGMENTED_MP4</code> container format
            packages the media into MP4 fragments (fMP4 or CMAF). This is
            the recommended packaging because there is minimal packaging
            overhead. The other container format option is
            <code>MPEG_TS</code>. HLS has supported MPEG TS chunks since
            it was released and is sometimes the only supported packaging
            on older HLS players. MPEG TS typically has a 5-25 percent
            packaging overhead. This means MPEG TS typically requires 5-25
            percent more bandwidth and cost than fMP4.
            </p>
            <p>
            The default is <code>FRAGMENTED_MP4</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="ContainerFormat.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>ContainerFormat</code></a></dd>
</dl>
</li>
</ul>
<a id="getDiscontinuityMode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDiscontinuityMode</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getDiscontinuityMode()</pre>
<div class="block"><p>
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.
 </p>
 <p>
 Media players typically build a timeline of media content to play, based
 on the timestamps of each fragment. This means that if there is any
 overlap or gap between fragments (as is typical if
 <a>HLSFragmentSelector</a> is set to <code>SERVER_TIMESTAMP</code>), the
 media player timeline will also have small gaps between fragments in some
 places, and will overwrite frames in other places. Gaps in the media
 player timeline can cause playback to stall and overlaps can cause
 playback to be jittery. When there are discontinuity flags between
 fragments, the media player is expected to reset the timeline, resulting
 in the next fragment being played immediately after the previous
 fragment.
 </p>
 <p>
 The following modes are supported:
 </p>
 <ul>
 <li>
 <p>
 <code>ALWAYS</code>: a discontinuity marker is placed between every
 fragment in the HLS media playlist. It is recommended to use a value of
 <code>ALWAYS</code> if the fragment timestamps are not accurate.
 </p>
 </li>
 <li>
 <p>
 <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
 recommended to use a value of <code>NEVER</code> to ensure the media
 player timeline most accurately maps to the producer timestamps.
 </p>
 </li>
 <li>
 <p>
 <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
 fragments that have a gap or overlap of more than 50 milliseconds. For
 most playback scenarios, it is recommended to use a value of
 <code>ON_DISCONTINUITY</code> so that the media player timeline is only
 reset when there is a significant issue with the media timeline (e.g. a
 missing fragment).
 </p>
 </li>
 </ul>
 <p>
 The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
 to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set
 to <code>PRODUCER_TIMESTAMP</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER, ON_DISCONTINUITY</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         Specifies when flags marking discontinuities between fragments
         are added to the media playlists.
         </p>
         <p>
         Media players typically build a timeline of media content to
         play, based on the timestamps of each fragment. This means that
         if there is any overlap or gap between fragments (as is typical
         if <a>HLSFragmentSelector</a> is set to
         <code>SERVER_TIMESTAMP</code>), the media player timeline will
         also have small gaps between fragments in some places, and will
         overwrite frames in other places. Gaps in the media player
         timeline can cause playback to stall and overlaps can cause
         playback to be jittery. When there are discontinuity flags
         between fragments, the media player is expected to reset the
         timeline, resulting in the next fragment being played immediately
         after the previous fragment.
         </p>
         <p>
         The following modes are supported:
         </p>
         <ul>
         <li>
         <p>
         <code>ALWAYS</code>: a discontinuity marker is placed between
         every fragment in the HLS media playlist. It is recommended to
         use a value of <code>ALWAYS</code> if the fragment timestamps are
         not accurate.
         </p>
         </li>
         <li>
         <p>
         <code>NEVER</code>: no discontinuity markers are placed anywhere.
         It is recommended to use a value of <code>NEVER</code> to ensure
         the media player timeline most accurately maps to the producer
         timestamps.
         </p>
         </li>
         <li>
         <p>
         <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed
         between fragments that have a gap or overlap of more than 50
         milliseconds. For most playback scenarios, it is recommended to
         use a value of <code>ON_DISCONTINUITY</code> so that the media
         player timeline is only reset when there is a significant issue
         with the media timeline (e.g. a missing fragment).
         </p>
         </li>
         </ul>
         <p>
         The default is <code>ALWAYS</code> when
         <a>HLSFragmentSelector</a> is set to
         <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is
         set to <code>PRODUCER_TIMESTAMP</code>.
         </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDiscontinuityMode</code></a></dd>
</dl>
</li>
</ul>
<a id="setDiscontinuityMode(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDiscontinuityMode</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDiscontinuityMode&#8203;(java.lang.String&nbsp;discontinuityMode)</pre>
<div class="block"><p>
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.
 </p>
 <p>
 Media players typically build a timeline of media content to play, based
 on the timestamps of each fragment. This means that if there is any
 overlap or gap between fragments (as is typical if
 <a>HLSFragmentSelector</a> is set to <code>SERVER_TIMESTAMP</code>), the
 media player timeline will also have small gaps between fragments in some
 places, and will overwrite frames in other places. Gaps in the media
 player timeline can cause playback to stall and overlaps can cause
 playback to be jittery. When there are discontinuity flags between
 fragments, the media player is expected to reset the timeline, resulting
 in the next fragment being played immediately after the previous
 fragment.
 </p>
 <p>
 The following modes are supported:
 </p>
 <ul>
 <li>
 <p>
 <code>ALWAYS</code>: a discontinuity marker is placed between every
 fragment in the HLS media playlist. It is recommended to use a value of
 <code>ALWAYS</code> if the fragment timestamps are not accurate.
 </p>
 </li>
 <li>
 <p>
 <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
 recommended to use a value of <code>NEVER</code> to ensure the media
 player timeline most accurately maps to the producer timestamps.
 </p>
 </li>
 <li>
 <p>
 <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
 fragments that have a gap or overlap of more than 50 milliseconds. For
 most playback scenarios, it is recommended to use a value of
 <code>ON_DISCONTINUITY</code> so that the media player timeline is only
 reset when there is a significant issue with the media timeline (e.g. a
 missing fragment).
 </p>
 </li>
 </ul>
 <p>
 The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
 to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set
 to <code>PRODUCER_TIMESTAMP</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER, ON_DISCONTINUITY</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>discontinuityMode</code> - <p>
            Specifies when flags marking discontinuities between fragments
            are added to the media playlists.
            </p>
            <p>
            Media players typically build a timeline of media content to
            play, based on the timestamps of each fragment. This means
            that if there is any overlap or gap between fragments (as is
            typical if <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>), the media player timeline will
            also have small gaps between fragments in some places, and
            will overwrite frames in other places. Gaps in the media
            player timeline can cause playback to stall and overlaps can
            cause playback to be jittery. When there are discontinuity
            flags between fragments, the media player is expected to reset
            the timeline, resulting in the next fragment being played
            immediately after the previous fragment.
            </p>
            <p>
            The following modes are supported:
            </p>
            <ul>
            <li>
            <p>
            <code>ALWAYS</code>: a discontinuity marker is placed between
            every fragment in the HLS media playlist. It is recommended to
            use a value of <code>ALWAYS</code> if the fragment timestamps
            are not accurate.
            </p>
            </li>
            <li>
            <p>
            <code>NEVER</code>: no discontinuity markers are placed
            anywhere. It is recommended to use a value of
            <code>NEVER</code> to ensure the media player timeline most
            accurately maps to the producer timestamps.
            </p>
            </li>
            <li>
            <p>
            <code>ON_DISCONTINUITY</code>: a discontinuity marker is
            placed between fragments that have a gap or overlap of more
            than 50 milliseconds. For most playback scenarios, it is
            recommended to use a value of <code>ON_DISCONTINUITY</code> so
            that the media player timeline is only reset when there is a
            significant issue with the media timeline (e.g. a missing
            fragment).
            </p>
            </li>
            </ul>
            <p>
            The default is <code>ALWAYS</code> when
            <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it
            is set to <code>PRODUCER_TIMESTAMP</code>.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDiscontinuityMode</code></a></dd>
</dl>
</li>
</ul>
<a id="withDiscontinuityMode(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withDiscontinuityMode</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withDiscontinuityMode&#8203;(java.lang.String&nbsp;discontinuityMode)</pre>
<div class="block"><p>
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.
 </p>
 <p>
 Media players typically build a timeline of media content to play, based
 on the timestamps of each fragment. This means that if there is any
 overlap or gap between fragments (as is typical if
 <a>HLSFragmentSelector</a> is set to <code>SERVER_TIMESTAMP</code>), the
 media player timeline will also have small gaps between fragments in some
 places, and will overwrite frames in other places. Gaps in the media
 player timeline can cause playback to stall and overlaps can cause
 playback to be jittery. When there are discontinuity flags between
 fragments, the media player is expected to reset the timeline, resulting
 in the next fragment being played immediately after the previous
 fragment.
 </p>
 <p>
 The following modes are supported:
 </p>
 <ul>
 <li>
 <p>
 <code>ALWAYS</code>: a discontinuity marker is placed between every
 fragment in the HLS media playlist. It is recommended to use a value of
 <code>ALWAYS</code> if the fragment timestamps are not accurate.
 </p>
 </li>
 <li>
 <p>
 <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
 recommended to use a value of <code>NEVER</code> to ensure the media
 player timeline most accurately maps to the producer timestamps.
 </p>
 </li>
 <li>
 <p>
 <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
 fragments that have a gap or overlap of more than 50 milliseconds. For
 most playback scenarios, it is recommended to use a value of
 <code>ON_DISCONTINUITY</code> so that the media player timeline is only
 reset when there is a significant issue with the media timeline (e.g. a
 missing fragment).
 </p>
 </li>
 </ul>
 <p>
 The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
 to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set
 to <code>PRODUCER_TIMESTAMP</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER, ON_DISCONTINUITY</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>discontinuityMode</code> - <p>
            Specifies when flags marking discontinuities between fragments
            are added to the media playlists.
            </p>
            <p>
            Media players typically build a timeline of media content to
            play, based on the timestamps of each fragment. This means
            that if there is any overlap or gap between fragments (as is
            typical if <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>), the media player timeline will
            also have small gaps between fragments in some places, and
            will overwrite frames in other places. Gaps in the media
            player timeline can cause playback to stall and overlaps can
            cause playback to be jittery. When there are discontinuity
            flags between fragments, the media player is expected to reset
            the timeline, resulting in the next fragment being played
            immediately after the previous fragment.
            </p>
            <p>
            The following modes are supported:
            </p>
            <ul>
            <li>
            <p>
            <code>ALWAYS</code>: a discontinuity marker is placed between
            every fragment in the HLS media playlist. It is recommended to
            use a value of <code>ALWAYS</code> if the fragment timestamps
            are not accurate.
            </p>
            </li>
            <li>
            <p>
            <code>NEVER</code>: no discontinuity markers are placed
            anywhere. It is recommended to use a value of
            <code>NEVER</code> to ensure the media player timeline most
            accurately maps to the producer timestamps.
            </p>
            </li>
            <li>
            <p>
            <code>ON_DISCONTINUITY</code>: a discontinuity marker is
            placed between fragments that have a gap or overlap of more
            than 50 milliseconds. For most playback scenarios, it is
            recommended to use a value of <code>ON_DISCONTINUITY</code> so
            that the media player timeline is only reset when there is a
            significant issue with the media timeline (e.g. a missing
            fragment).
            </p>
            </li>
            </ul>
            <p>
            The default is <code>ALWAYS</code> when
            <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it
            is set to <code>PRODUCER_TIMESTAMP</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDiscontinuityMode</code></a></dd>
</dl>
</li>
</ul>
<a id="setDiscontinuityMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDiscontinuityMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDiscontinuityMode</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDiscontinuityMode&#8203;(<a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDiscontinuityMode</a>&nbsp;discontinuityMode)</pre>
<div class="block"><p>
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.
 </p>
 <p>
 Media players typically build a timeline of media content to play, based
 on the timestamps of each fragment. This means that if there is any
 overlap or gap between fragments (as is typical if
 <a>HLSFragmentSelector</a> is set to <code>SERVER_TIMESTAMP</code>), the
 media player timeline will also have small gaps between fragments in some
 places, and will overwrite frames in other places. Gaps in the media
 player timeline can cause playback to stall and overlaps can cause
 playback to be jittery. When there are discontinuity flags between
 fragments, the media player is expected to reset the timeline, resulting
 in the next fragment being played immediately after the previous
 fragment.
 </p>
 <p>
 The following modes are supported:
 </p>
 <ul>
 <li>
 <p>
 <code>ALWAYS</code>: a discontinuity marker is placed between every
 fragment in the HLS media playlist. It is recommended to use a value of
 <code>ALWAYS</code> if the fragment timestamps are not accurate.
 </p>
 </li>
 <li>
 <p>
 <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
 recommended to use a value of <code>NEVER</code> to ensure the media
 player timeline most accurately maps to the producer timestamps.
 </p>
 </li>
 <li>
 <p>
 <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
 fragments that have a gap or overlap of more than 50 milliseconds. For
 most playback scenarios, it is recommended to use a value of
 <code>ON_DISCONTINUITY</code> so that the media player timeline is only
 reset when there is a significant issue with the media timeline (e.g. a
 missing fragment).
 </p>
 </li>
 </ul>
 <p>
 The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
 to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set
 to <code>PRODUCER_TIMESTAMP</code>.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER, ON_DISCONTINUITY</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>discontinuityMode</code> - <p>
            Specifies when flags marking discontinuities between fragments
            are added to the media playlists.
            </p>
            <p>
            Media players typically build a timeline of media content to
            play, based on the timestamps of each fragment. This means
            that if there is any overlap or gap between fragments (as is
            typical if <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>), the media player timeline will
            also have small gaps between fragments in some places, and
            will overwrite frames in other places. Gaps in the media
            player timeline can cause playback to stall and overlaps can
            cause playback to be jittery. When there are discontinuity
            flags between fragments, the media player is expected to reset
            the timeline, resulting in the next fragment being played
            immediately after the previous fragment.
            </p>
            <p>
            The following modes are supported:
            </p>
            <ul>
            <li>
            <p>
            <code>ALWAYS</code>: a discontinuity marker is placed between
            every fragment in the HLS media playlist. It is recommended to
            use a value of <code>ALWAYS</code> if the fragment timestamps
            are not accurate.
            </p>
            </li>
            <li>
            <p>
            <code>NEVER</code>: no discontinuity markers are placed
            anywhere. It is recommended to use a value of
            <code>NEVER</code> to ensure the media player timeline most
            accurately maps to the producer timestamps.
            </p>
            </li>
            <li>
            <p>
            <code>ON_DISCONTINUITY</code>: a discontinuity marker is
            placed between fragments that have a gap or overlap of more
            than 50 milliseconds. For most playback scenarios, it is
            recommended to use a value of <code>ON_DISCONTINUITY</code> so
            that the media player timeline is only reset when there is a
            significant issue with the media timeline (e.g. a missing
            fragment).
            </p>
            </li>
            </ul>
            <p>
            The default is <code>ALWAYS</code> when
            <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it
            is set to <code>PRODUCER_TIMESTAMP</code>.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDiscontinuityMode</code></a></dd>
</dl>
</li>
</ul>
<a id="withDiscontinuityMode(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDiscontinuityMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withDiscontinuityMode</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withDiscontinuityMode&#8203;(<a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDiscontinuityMode</a>&nbsp;discontinuityMode)</pre>
<div class="block"><p>
 Specifies when flags marking discontinuities between fragments are added
 to the media playlists.
 </p>
 <p>
 Media players typically build a timeline of media content to play, based
 on the timestamps of each fragment. This means that if there is any
 overlap or gap between fragments (as is typical if
 <a>HLSFragmentSelector</a> is set to <code>SERVER_TIMESTAMP</code>), the
 media player timeline will also have small gaps between fragments in some
 places, and will overwrite frames in other places. Gaps in the media
 player timeline can cause playback to stall and overlaps can cause
 playback to be jittery. When there are discontinuity flags between
 fragments, the media player is expected to reset the timeline, resulting
 in the next fragment being played immediately after the previous
 fragment.
 </p>
 <p>
 The following modes are supported:
 </p>
 <ul>
 <li>
 <p>
 <code>ALWAYS</code>: a discontinuity marker is placed between every
 fragment in the HLS media playlist. It is recommended to use a value of
 <code>ALWAYS</code> if the fragment timestamps are not accurate.
 </p>
 </li>
 <li>
 <p>
 <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
 recommended to use a value of <code>NEVER</code> to ensure the media
 player timeline most accurately maps to the producer timestamps.
 </p>
 </li>
 <li>
 <p>
 <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
 fragments that have a gap or overlap of more than 50 milliseconds. For
 most playback scenarios, it is recommended to use a value of
 <code>ON_DISCONTINUITY</code> so that the media player timeline is only
 reset when there is a significant issue with the media timeline (e.g. a
 missing fragment).
 </p>
 </li>
 </ul>
 <p>
 The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
 to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set
 to <code>PRODUCER_TIMESTAMP</code>.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER, ON_DISCONTINUITY</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>discontinuityMode</code> - <p>
            Specifies when flags marking discontinuities between fragments
            are added to the media playlists.
            </p>
            <p>
            Media players typically build a timeline of media content to
            play, based on the timestamps of each fragment. This means
            that if there is any overlap or gap between fragments (as is
            typical if <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>), the media player timeline will
            also have small gaps between fragments in some places, and
            will overwrite frames in other places. Gaps in the media
            player timeline can cause playback to stall and overlaps can
            cause playback to be jittery. When there are discontinuity
            flags between fragments, the media player is expected to reset
            the timeline, resulting in the next fragment being played
            immediately after the previous fragment.
            </p>
            <p>
            The following modes are supported:
            </p>
            <ul>
            <li>
            <p>
            <code>ALWAYS</code>: a discontinuity marker is placed between
            every fragment in the HLS media playlist. It is recommended to
            use a value of <code>ALWAYS</code> if the fragment timestamps
            are not accurate.
            </p>
            </li>
            <li>
            <p>
            <code>NEVER</code>: no discontinuity markers are placed
            anywhere. It is recommended to use a value of
            <code>NEVER</code> to ensure the media player timeline most
            accurately maps to the producer timestamps.
            </p>
            </li>
            <li>
            <p>
            <code>ON_DISCONTINUITY</code>: a discontinuity marker is
            placed between fragments that have a gap or overlap of more
            than 50 milliseconds. For most playback scenarios, it is
            recommended to use a value of <code>ON_DISCONTINUITY</code> so
            that the media player timeline is only reset when there is a
            significant issue with the media timeline (e.g. a missing
            fragment).
            </p>
            </li>
            </ul>
            <p>
            The default is <code>ALWAYS</code> when
            <a>HLSFragmentSelector</a> is set to
            <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it
            is set to <code>PRODUCER_TIMESTAMP</code>.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDiscontinuityMode.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDiscontinuityMode</code></a></dd>
</dl>
</li>
</ul>
<a id="getDisplayFragmentTimestamp()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDisplayFragmentTimestamp</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;getDisplayFragmentTimestamp()</pre>
<div class="block"><p>
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist. Typically, media players report the playhead position
 as a time relative to the start of the first fragment in the playback
 session. However, when the start timestamps are included in the HLS media
 playlist, some media players might report the current playhead as an
 absolute time based on the fragment timestamps. This can be useful for
 creating a playback experience that shows viewers the wall-clock time of
 the media.
 </p>
 <p>
 The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
 <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start
 timestamps. Similarly, when <a>HLSFragmentSelector</a> is
 <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer
 start timestamps.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         Specifies when the fragment start timestamps should be included
         in the HLS media playlist. Typically, media players report the
         playhead position as a time relative to the start of the first
         fragment in the playback session. However, when the start
         timestamps are included in the HLS media playlist, some media
         players might report the current playhead as an absolute time
         based on the fragment timestamps. This can be useful for creating
         a playback experience that shows viewers the wall-clock time of
         the media.
         </p>
         <p>
         The default is <code>NEVER</code>. When
         <a>HLSFragmentSelector</a> is <code>SERVER_TIMESTAMP</code>, the
         timestamps will be the server start timestamps. Similarly, when
         <a>HLSFragmentSelector</a> is <code>PRODUCER_TIMESTAMP</code>,
         the timestamps will be the producer start timestamps.
         </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDisplayFragmentTimestamp</code></a></dd>
</dl>
</li>
</ul>
<a id="setDisplayFragmentTimestamp(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDisplayFragmentTimestamp</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDisplayFragmentTimestamp&#8203;(java.lang.String&nbsp;displayFragmentTimestamp)</pre>
<div class="block"><p>
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist. Typically, media players report the playhead position
 as a time relative to the start of the first fragment in the playback
 session. However, when the start timestamps are included in the HLS media
 playlist, some media players might report the current playhead as an
 absolute time based on the fragment timestamps. This can be useful for
 creating a playback experience that shows viewers the wall-clock time of
 the media.
 </p>
 <p>
 The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
 <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start
 timestamps. Similarly, when <a>HLSFragmentSelector</a> is
 <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer
 start timestamps.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>displayFragmentTimestamp</code> - <p>
            Specifies when the fragment start timestamps should be
            included in the HLS media playlist. Typically, media players
            report the playhead position as a time relative to the start
            of the first fragment in the playback session. However, when
            the start timestamps are included in the HLS media playlist,
            some media players might report the current playhead as an
            absolute time based on the fragment timestamps. This can be
            useful for creating a playback experience that shows viewers
            the wall-clock time of the media.
            </p>
            <p>
            The default is <code>NEVER</code>. When
            <a>HLSFragmentSelector</a> is <code>SERVER_TIMESTAMP</code>,
            the timestamps will be the server start timestamps. Similarly,
            when <a>HLSFragmentSelector</a> is
            <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the
            producer start timestamps.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDisplayFragmentTimestamp</code></a></dd>
</dl>
</li>
</ul>
<a id="withDisplayFragmentTimestamp(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withDisplayFragmentTimestamp</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withDisplayFragmentTimestamp&#8203;(java.lang.String&nbsp;displayFragmentTimestamp)</pre>
<div class="block"><p>
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist. Typically, media players report the playhead position
 as a time relative to the start of the first fragment in the playback
 session. However, when the start timestamps are included in the HLS media
 playlist, some media players might report the current playhead as an
 absolute time based on the fragment timestamps. This can be useful for
 creating a playback experience that shows viewers the wall-clock time of
 the media.
 </p>
 <p>
 The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
 <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start
 timestamps. Similarly, when <a>HLSFragmentSelector</a> is
 <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer
 start timestamps.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>displayFragmentTimestamp</code> - <p>
            Specifies when the fragment start timestamps should be
            included in the HLS media playlist. Typically, media players
            report the playhead position as a time relative to the start
            of the first fragment in the playback session. However, when
            the start timestamps are included in the HLS media playlist,
            some media players might report the current playhead as an
            absolute time based on the fragment timestamps. This can be
            useful for creating a playback experience that shows viewers
            the wall-clock time of the media.
            </p>
            <p>
            The default is <code>NEVER</code>. When
            <a>HLSFragmentSelector</a> is <code>SERVER_TIMESTAMP</code>,
            the timestamps will be the server start timestamps. Similarly,
            when <a>HLSFragmentSelector</a> is
            <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the
            producer start timestamps.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDisplayFragmentTimestamp</code></a></dd>
</dl>
</li>
</ul>
<a id="setDisplayFragmentTimestamp(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDisplayFragmentTimestamp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDisplayFragmentTimestamp</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDisplayFragmentTimestamp&#8203;(<a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDisplayFragmentTimestamp</a>&nbsp;displayFragmentTimestamp)</pre>
<div class="block"><p>
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist. Typically, media players report the playhead position
 as a time relative to the start of the first fragment in the playback
 session. However, when the start timestamps are included in the HLS media
 playlist, some media players might report the current playhead as an
 absolute time based on the fragment timestamps. This can be useful for
 creating a playback experience that shows viewers the wall-clock time of
 the media.
 </p>
 <p>
 The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
 <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start
 timestamps. Similarly, when <a>HLSFragmentSelector</a> is
 <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer
 start timestamps.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>displayFragmentTimestamp</code> - <p>
            Specifies when the fragment start timestamps should be
            included in the HLS media playlist. Typically, media players
            report the playhead position as a time relative to the start
            of the first fragment in the playback session. However, when
            the start timestamps are included in the HLS media playlist,
            some media players might report the current playhead as an
            absolute time based on the fragment timestamps. This can be
            useful for creating a playback experience that shows viewers
            the wall-clock time of the media.
            </p>
            <p>
            The default is <code>NEVER</code>. When
            <a>HLSFragmentSelector</a> is <code>SERVER_TIMESTAMP</code>,
            the timestamps will be the server start timestamps. Similarly,
            when <a>HLSFragmentSelector</a> is
            <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the
            producer start timestamps.
            </p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDisplayFragmentTimestamp</code></a></dd>
</dl>
</li>
</ul>
<a id="withDisplayFragmentTimestamp(com.amazonaws.services.kinesisvideoarchivedmedia.model.HLSDisplayFragmentTimestamp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withDisplayFragmentTimestamp</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withDisplayFragmentTimestamp&#8203;(<a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model">HLSDisplayFragmentTimestamp</a>&nbsp;displayFragmentTimestamp)</pre>
<div class="block"><p>
 Specifies when the fragment start timestamps should be included in the
 HLS media playlist. Typically, media players report the playhead position
 as a time relative to the start of the first fragment in the playback
 session. However, when the start timestamps are included in the HLS media
 playlist, some media players might report the current playhead as an
 absolute time based on the fragment timestamps. This can be useful for
 creating a playback experience that shows viewers the wall-clock time of
 the media.
 </p>
 <p>
 The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
 <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start
 timestamps. Similarly, when <a>HLSFragmentSelector</a> is
 <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer
 start timestamps.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Allowed Values: </b>ALWAYS, NEVER</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>displayFragmentTimestamp</code> - <p>
            Specifies when the fragment start timestamps should be
            included in the HLS media playlist. Typically, media players
            report the playhead position as a time relative to the start
            of the first fragment in the playback session. However, when
            the start timestamps are included in the HLS media playlist,
            some media players might report the current playhead as an
            absolute time based on the fragment timestamps. This can be
            useful for creating a playback experience that shows viewers
            the wall-clock time of the media.
            </p>
            <p>
            The default is <code>NEVER</code>. When
            <a>HLSFragmentSelector</a> is <code>SERVER_TIMESTAMP</code>,
            the timestamps will be the server start timestamps. Similarly,
            when <a>HLSFragmentSelector</a> is
            <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the
            producer start timestamps.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="HLSDisplayFragmentTimestamp.html" title="enum in com.amazonaws.services.kinesisvideoarchivedmedia.model"><code>HLSDisplayFragmentTimestamp</code></a></dd>
</dl>
</li>
</ul>
<a id="getExpires()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExpires</h4>
<pre class="methodSignature">public&nbsp;java.lang.Integer&nbsp;getExpires()</pre>
<div class="block"><p>
 The time in seconds until the requested session expires. This value can
 be between 300 (5 minutes) and 43200 (12 hours).
 </p>
 <p>
 When a session expires, no new calls to <code>GetHLSMasterPlaylist</code>, <code>GetHLSMediaPlaylist</code>, <code>GetMP4InitFragment</code>,
 <code>GetMP4MediaFragment</code>, or <code>GetTSFragment</code> can be
 made for that session.
 </p>
 <p>
 The default is 300 (5 minutes).
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Range: </b>300 - 43200<br/></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         The time in seconds until the requested session expires. This
         value can be between 300 (5 minutes) and 43200 (12 hours).
         </p>
         <p>
         When a session expires, no new calls to
         <code>GetHLSMasterPlaylist</code>,
         <code>GetHLSMediaPlaylist</code>, <code>GetMP4InitFragment</code>, <code>GetMP4MediaFragment</code>, or <code>GetTSFragment</code>
         can be made for that session.
         </p>
         <p>
         The default is 300 (5 minutes).
         </p></dd>
</dl>
</li>
</ul>
<a id="setExpires(java.lang.Integer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExpires</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setExpires&#8203;(java.lang.Integer&nbsp;expires)</pre>
<div class="block"><p>
 The time in seconds until the requested session expires. This value can
 be between 300 (5 minutes) and 43200 (12 hours).
 </p>
 <p>
 When a session expires, no new calls to <code>GetHLSMasterPlaylist</code>, <code>GetHLSMediaPlaylist</code>, <code>GetMP4InitFragment</code>,
 <code>GetMP4MediaFragment</code>, or <code>GetTSFragment</code> can be
 made for that session.
 </p>
 <p>
 The default is 300 (5 minutes).
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Range: </b>300 - 43200<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expires</code> - <p>
            The time in seconds until the requested session expires. This
            value can be between 300 (5 minutes) and 43200 (12 hours).
            </p>
            <p>
            When a session expires, no new calls to
            <code>GetHLSMasterPlaylist</code>,
            <code>GetHLSMediaPlaylist</code>,
            <code>GetMP4InitFragment</code>,
            <code>GetMP4MediaFragment</code>, or
            <code>GetTSFragment</code> can be made for that session.
            </p>
            <p>
            The default is 300 (5 minutes).
            </p></dd>
</dl>
</li>
</ul>
<a id="withExpires(java.lang.Integer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withExpires</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withExpires&#8203;(java.lang.Integer&nbsp;expires)</pre>
<div class="block"><p>
 The time in seconds until the requested session expires. This value can
 be between 300 (5 minutes) and 43200 (12 hours).
 </p>
 <p>
 When a session expires, no new calls to <code>GetHLSMasterPlaylist</code>, <code>GetHLSMediaPlaylist</code>, <code>GetMP4InitFragment</code>,
 <code>GetMP4MediaFragment</code>, or <code>GetTSFragment</code> can be
 made for that session.
 </p>
 <p>
 The default is 300 (5 minutes).
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Range: </b>300 - 43200<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expires</code> - <p>
            The time in seconds until the requested session expires. This
            value can be between 300 (5 minutes) and 43200 (12 hours).
            </p>
            <p>
            When a session expires, no new calls to
            <code>GetHLSMasterPlaylist</code>,
            <code>GetHLSMediaPlaylist</code>,
            <code>GetMP4InitFragment</code>,
            <code>GetMP4MediaFragment</code>, or
            <code>GetTSFragment</code> can be made for that session.
            </p>
            <p>
            The default is 300 (5 minutes).
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
</dl>
</li>
</ul>
<a id="getMaxMediaPlaylistFragmentResults()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxMediaPlaylistFragmentResults</h4>
<pre class="methodSignature">public&nbsp;java.lang.Long&nbsp;getMaxMediaPlaylistFragmentResults()</pre>
<div class="block"><p>
 The maximum number of fragments that are returned in the HLS media
 playlists.
 </p>
 <p>
 When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent
 fragments are returned up to this value. When the
 <code>PlaybackMode</code> is <code>ON_DEMAND</code>, the oldest fragments
 are returned, up to this maximum number.
 </p>
 <p>
 When there are a higher number of fragments available in a live HLS media
 playlist, video players often buffer content before starting playback.
 Increasing the buffer size increases the playback latency, but it
 decreases the likelihood that rebuffering will occur during playback. We
 recommend that a live HLS media playlist have a minimum of 3 fragments
 and a maximum of 10 fragments.
 </p>
 <p>
 The default is 5 fragments if <code>PlaybackMode</code> is
 <code>LIVE</code> or <code>LIVE_REPLAY</code>, and 1,000 if
 <code>PlaybackMode</code> is <code>ON_DEMAND</code>.
 </p>
 <p>
 The maximum value of 5,000 fragments corresponds to more than 80 minutes
 of video on streams with 1-second fragments, and more than 13 hours of
 video on streams with 10-second fragments.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Range: </b>1 - 5000<br/></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><p>
         The maximum number of fragments that are returned in the HLS
         media playlists.
         </p>
         <p>
         When the <code>PlaybackMode</code> is <code>LIVE</code>, the most
         recent fragments are returned up to this value. When the
         <code>PlaybackMode</code> is <code>ON_DEMAND</code>, the oldest
         fragments are returned, up to this maximum number.
         </p>
         <p>
         When there are a higher number of fragments available in a live
         HLS media playlist, video players often buffer content before
         starting playback. Increasing the buffer size increases the
         playback latency, but it decreases the likelihood that
         rebuffering will occur during playback. We recommend that a live
         HLS media playlist have a minimum of 3 fragments and a maximum of
         10 fragments.
         </p>
         <p>
         The default is 5 fragments if <code>PlaybackMode</code> is
         <code>LIVE</code> or <code>LIVE_REPLAY</code>, and 1,000 if
         <code>PlaybackMode</code> is <code>ON_DEMAND</code>.
         </p>
         <p>
         The maximum value of 5,000 fragments corresponds to more than 80
         minutes of video on streams with 1-second fragments, and more
         than 13 hours of video on streams with 10-second fragments.
         </p></dd>
</dl>
</li>
</ul>
<a id="setMaxMediaPlaylistFragmentResults(java.lang.Long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxMediaPlaylistFragmentResults</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMaxMediaPlaylistFragmentResults&#8203;(java.lang.Long&nbsp;maxMediaPlaylistFragmentResults)</pre>
<div class="block"><p>
 The maximum number of fragments that are returned in the HLS media
 playlists.
 </p>
 <p>
 When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent
 fragments are returned up to this value. When the
 <code>PlaybackMode</code> is <code>ON_DEMAND</code>, the oldest fragments
 are returned, up to this maximum number.
 </p>
 <p>
 When there are a higher number of fragments available in a live HLS media
 playlist, video players often buffer content before starting playback.
 Increasing the buffer size increases the playback latency, but it
 decreases the likelihood that rebuffering will occur during playback. We
 recommend that a live HLS media playlist have a minimum of 3 fragments
 and a maximum of 10 fragments.
 </p>
 <p>
 The default is 5 fragments if <code>PlaybackMode</code> is
 <code>LIVE</code> or <code>LIVE_REPLAY</code>, and 1,000 if
 <code>PlaybackMode</code> is <code>ON_DEMAND</code>.
 </p>
 <p>
 The maximum value of 5,000 fragments corresponds to more than 80 minutes
 of video on streams with 1-second fragments, and more than 13 hours of
 video on streams with 10-second fragments.
 </p>
 <p>
 <b>Constraints:</b><br/>
 <b>Range: </b>1 - 5000<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxMediaPlaylistFragmentResults</code> - <p>
            The maximum number of fragments that are returned in the HLS
            media playlists.
            </p>
            <p>
            When the <code>PlaybackMode</code> is <code>LIVE</code>, the
            most recent fragments are returned up to this value. When the
            <code>PlaybackMode</code> is <code>ON_DEMAND</code>, the
            oldest fragments are returned, up to this maximum number.
            </p>
            <p>
            When there are a higher number of fragments available in a
            live HLS media playlist, video players often buffer content
            before starting playback. Increasing the buffer size increases
            the playback latency, but it decreases the likelihood that
            rebuffering will occur during playback. We recommend that a
            live HLS media playlist have a minimum of 3 fragments and a
            maximum of 10 fragments.
            </p>
            <p>
            The default is 5 fragments if <code>PlaybackMode</code> is
            <code>LIVE</code> or <code>LIVE_REPLAY</code>, and 1,000 if
            <code>PlaybackMode</code> is <code>ON_DEMAND</code>.
            </p>
            <p>
            The maximum value of 5,000 fragments corresponds to more than
            80 minutes of video on streams with 1-second fragments, and
            more than 13 hours of video on streams with 10-second
            fragments.
            </p></dd>
</dl>
</li>
</ul>
<a id="withMaxMediaPlaylistFragmentResults(java.lang.Long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withMaxMediaPlaylistFragmentResults</h4>
<pre class="methodSignature">public&nbsp;<a href="GetHLSStreamingSessionURLRequest.html" title="class in com.amazonaws.services.kinesisvideoarchivedmedia.model">GetHLSStreamingSessionURLRequest</a>&nbsp;withMaxMediaPlaylistFragmentResults&#8203;(java.lang.Long&nbsp;maxMediaPlaylistFragmentResults)</pre>
<div class="block"><p>
 The maximum number of fragments that are returned in the HLS media
 playlists.
 </p>
 <p>
 When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent
 fragments are returned up to this value. When the
 <code>PlaybackMode</code> is <code>ON_DEMAND</code>, the oldest fragments
 are returned, up to this maximum number.
 </p>
 <p>
 When there are a higher number of fragments available in a live HLS media
 playlist, video players often buffer content before starting playback.
 Increasing the buffer size increases the playback latency, but it
 decreases the likelihood that rebuffering will occur during playback. We
 recommend that a live HLS media playlist have a minimum of 3 fragments
 and a maximum of 10 fragments.
 </p>
 <p>
 The default is 5 fragments if <code>PlaybackMode</code> is
 <code>LIVE</code> or <code>LIVE_REPLAY</code>, and 1,000 if
 <code>PlaybackMode</code> is <code>ON_DEMAND</code>.
 </p>
 <p>
 The maximum value of 5,000 fragments corresponds to more than 80 minutes
 of video on streams with 1-second fragments, and more than 13 hours of
 video on streams with 10-second fragments.
 </p>
 <p>
 Returns a reference to this object so that method calls can be chained
 together.
 <p>
 <b>Constraints:</b><br/>
 <b>Range: </b>1 - 5000<br/></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxMediaPlaylistFragmentResults</code> - <p>
            The maximum number of fragments that are returned in the HLS
            media playlists.
            </p>
            <p>
            When the <code>PlaybackMode</code> is <code>LIVE</code>, the
            most recent fragments are returned up to this value. When the
            <code>PlaybackMode</code> is <code>ON_DEMAND</code>, the
            oldest fragments are returned, up to this maximum number.
            </p>
            <p>
            When there are a higher number of fragments available in a
            live HLS media playlist, video players often buffer content
            before starting playback. Increasing the buffer size increases
            the playback latency, but it decreases the likelihood that
            rebuffering will occur during playback. We recommend that a
            live HLS media playlist have a minimum of 3 fragments and a
            maximum of 10 fragments.
            </p>
            <p>
            The default is 5 fragments if <code>PlaybackMode</code> is
            <code>LIVE</code> or <code>LIVE_REPLAY</code>, and 1,000 if
            <code>PlaybackMode</code> is <code>ON_DEMAND</code>.
            </p>
            <p>
            The maximum value of 5,000 fragments corresponds to more than
            80 minutes of video on streams with 1-second fragments, and
            more than 13 hours of video on streams with 10-second
            fragments.
            </p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A reference to this updated object so that method calls can be
         chained together.</dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a string representation of this object; useful for testing and
 debugging.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A string representation of this object.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Object.toString()</code></dd>
</dl>
</li>
</ul>
<a id="hashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;hashCode()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>hashCode</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a id="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>equals</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;equals&#8203;(java.lang.Object&nbsp;obj)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2022 Amazon Web Services, Inc. All Rights Reserved.</small></p>
</footer>
</body>
</html>
